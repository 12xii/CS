# Non-linear data structure 비선형 자료 구조

- 비선형 자료 구조 : 하나의 데이터 뒤에 N개의 데이터가 이어질 수 있는, 1:N / N:N 구조로 데이터가 나열

---

## 그래프 Graph

- 데이터를 포함하는 정점 vertex / node 과 정점을 잇는 간선 edge 로 구성된 자료구조
- 일반적인 그래프의 표현식은 각 용어의 앞 글자를 따 $ G = (V, E) $로 표현

### 용어
- 인접 adjacent : 두 정점이 간선으로 연결된 경우
- 차수 degree : 정점에 연결된 간선의 수
- 진입 차수 in-degree : 해당 정점으로 향하는 간선의 수를 의미
- 진출 차수 out-degree : 해당 정점에서 나가는 간선의 수
- 경로 path : 한 정점에서 다른 정점으로 이어지는 정점들의 리스트
- 경로 길이 path length : 경로를 구성하는 간선의 수
- 단순 경로 simple path : 모두 다른 정점으로 구성된 경로를 의미
- 사이클 cycle : 한 정점에서 시작해 같은 정점으로 돌아올 수 있는 경로를 의미

### 종류
- 무방향 그래프 undirected graph
    - 간선에 방향성 X
    - 두 정점 $A, B$가 인접할 때 간선 $(A, B)$와 $(B, A)$는 동일함
    - 정점의 개수가 $n$개일 때 최대 간선의 개수는 $n \times (n - 1) \div 2$ 개
- 방향 그래프 directed graph
    - 간선에 방향성 O
    - 두 정점이 인접할 때 $A$에서 $B$로 향하는 간선을 $\left\langle A , B\right\rangle $로 표시
        - $\left\langle A, B\right\rangle$과 $\left\langle B, A \right\rangle$은 다른 간선
    - 정점의 개수가 $n$개일 때 최대 간선의 개수는 $n \times (n - 1)$ 개
- 부분 그래프 sub graph 
    - 기존 그래프에서 일부 정점이나 간선을 제외
- 가중치 그래프 weighted graph
    - 간선에 비용이나 가중치가 할당됨
- 완전 그래프 complete graph / 연결 그래프 connected graph
    - 간선을 최대로 가짐
    - 정점의 개수가 $n$개일 때 무방향 그래프의 간선 수가 $n \times (n - 1) \div 2$이면 완전 그래프
    - 정점의 개수가 $n$개일 때 방향 그래프의 간선 수가 $n \times (n - 1)$이면 완전 그래프
- 유향 비순환 그래프 DAG, Directed Acyclic Graph
    - 방향 그래프이면서 사이클이 없는 그래프

### 경로 탐색
- 너비 우선 탐색 BFS, Breadth-First Search
    - 탐색을 시작하는 정점에서 가까운 정점을 먼저 탐색
    - 발견한 정점과 인접한 정점들을 탐색하며 이전에 방문했는지 확인 이후 큐에 삽입
    - 과정
        1. 시작 정점을 인큐, 인접한 정점들을 역시 인큐한 뒤 방문할 노드가 더이상 없으면 시작 정점을 디큐
        2. 큐의 프론트에 있는 정점에서 방문한 정점 제외 인접한 정점을 인큐하고 디큐
        3. 2의 과정을 큐가 빌 때까지 반복
    - 비가중치 그래프에서 시작 정점부터 특정 정점까지의 최단 거리를 알 수 있음
![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99960F405BD01A8D18)

- 깊이 우선 탐색 DFS, Depth-First Search
    - 시작 정점에서 탐색 가능한 최대 깊이의 정점까지 탐색
    - 재귀 또는 스택으로 구현
    - 과정
        1. 시작 정점 A를 스택에 push, 인접한 탐색 가능한 정점 중 한 정점 B를 방문하고 푸시
        2. B에서 인접한 탐색 가능한 정점을 방문하고 스택에 푸시
        3. 더 이상 탐색 가능한 정점이 없을 때까지 2를 반복
        4. 더 이상 탐색 가능한 정점이 없다 = 탐색 가능한 최대 깊이에 도달했음이므로 스택에서 pop하여 역순으로 방문하며 탐색 가능한 정점이 있는지 확인
    - 특정 정점에서 다른 정점까지의 경로를 알 수 있음
        - 재귀 호출로 구현 시 방문해야 하는 정점을 저장할 필요가 없어 BFS 대비 저장 공간을 적게 사용
![](https://gmlwjd9405.github.io/images/algorithm-dfs-vs-bfs/dfs-example.png)

## 트리 Tree

- 그래프의 한 종류
- 사이클이 없어 계층적 관계의 표현이 가능

### 용어

![](https://i0.wp.com/hanamon.kr/wp-content/uploads/2021/07/%E1%84%8C%E1%85%A1%E1%84%85%E1%85%AD%E1%84%80%E1%85%AE%E1%84%8C%E1%85%A9-%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5-%E1%84%8B%E1%85%AD%E1%86%BC%E1%84%8B%E1%85%A5.png?resize=975%2C551&ssl=1)

- 루트 노드 root node : 부모 노드가 없는 노드
    - 트리의 루트 노드는 단 하나만 존재
- 부모 노드 parent node : 루트 노드 방향으로 연결된 노드
- 자식 노드 child node : 루트 노드의 반대 방향으로 연결된 노드
- 단말 노드 leaf node : 자식 노드가 없는 노드
- 형제 노드 sibling node : 같은 부모 노드를 가진 노드
- 레벨 level : 루트 노드로부터 노드의 상대적 위치
    - 일반적으로 루트 노드의 레벨은 0
- 높이 height : 트리의 최대 레벨 + 1
- 차수 degree : 자식 노드의 개수

### 종류 (이진 트리)
![](https://images.velog.io/images/kkimbj18/post/97908fb6-00b2-4e36-a698-1070cc6f28e1/image.png)

- 이진 트리 binary tree
    - 자식 노드가 최대 2개인 트리

- 완전 이진 트리 complete binary tree
    - 트리의 마지막 레벨을 제외한 모든 레벨에 노드가 채워져 있음
    - 마지막 레벨은 왼쪽으로부터 오른쪽으로 향할 때 중간에 비는 노드가 없음

- 포화 이진 트리 perfect binary tree
    - 트리의 마지막 레벨까지 노드가 모두 채워져 있는 이진 트리
    - 포화 이진 트리는 완전 이진 트리에 속함

- 이진 탐색 트리 BST, binary search tree
    - 한 노드 $B$에서 왼쪽 서브 트리를 $A$, 오른쪽 서브 트리를 $C$라고 할 때 $A < B < C$가 되는 트리
    - 균형 잡힌 BST에서는 루트와 가까울수록 검색에 필요한 노드 개수가 반감 => 노드 개수를 $n$이라고 할 때, 값 검색에 $O(\log n)$이 소요
    - 균형 잡히지 않은 BST에서는 시간 복잡도가 $O(n)$이므로 BST의 이점이 사라짐

    - 연산
        - 데이터 삽입
            - 루트 노드부터 차례대로 값을 비교해 나가며 삽입할 자리를 찾음
            - 추가하려는 데이터 $B$가 비교하는 노드 $A$보다 클 경우 오른쪽 자식 노드와 비교 수행, $A$보다 작을 경우 왼쪽 자식 노드와 비교 수행
        - 데이터 삭제
            
            1. 단말 노드 삭제 - 해당 노드만 삭제
            2. 자식 노드가 1개 존재할 경우 - 자식 노드를 삭제할 노드의 위치로 올림
            3. 자식 노드가 2개 존재할 경우 - 오른쪽 서브 트리에서 가장 작은 값 or 왼쪽 서브 트리에서 가장 큰 값을 삭제할 노드의 위치로 올림
    - 균형 이진 탐색 트리 balanced BST
        - 레드-블랙 트리 red-black tree
            - 트리의 데이터에 대한 연산 수행 시 조건을 만족하도록 회전과 색 변환을 통해 노드 재배치가 필요
            - 조건 
                - 모든 노드는 검은색 또는 빨간색
                - 루트 노드는 검은색
                - 단말 노드 (NIL) 은 검은색
                    - 단말 노드는 트리의 끝을 나타내며 값을 갖지 않음
                - 빨간색 노드의 자식은 검은색이며 빨간색 노드의 연속 출현은 금지
                    - 검은색은 연속 가능
                - 루트 노드에서 임의의 단말 노드까지 경로에 있는 검은색 노드의 개수는 모두 같음
        - AVL 트리 AVL tree
            - 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차이를 유지해 균형 유지
            - 높이 차이를 알기 위해 (왼쪽 버스 트리의 높이) - (오른쪽 서브 트리의 높이) 값인 BF(Balance Factor) 사용
                - BF는 최대 1
                - BF > 1이 될 경우 균형을 잡아 높이 차이를 줄인다
            - 불균형 상황
                - LL (Left Left) 불균형 : 왼쪽으로 불균형
                    - 가운데 노드 중심으로 오른쪽 회전
                - RR (Right Right) 불균형 : 오른쪽으로 불균형
                    - 가운데 노드 중심으로 왼쪽 회전
                - LR (Left Right) 불균형 : 왼쪽 - 오른쪽으로 불균형
                    - 마지막 레벨 노드를 중심으로 왼쪽 - 오른쪽 회전
                - RL (Right Left) 불균형 : 오른쪽 - 왼쪽으로 불균형
                    - 마지막 레벨 노드를 중심으로 오른쪽 - 왼쪽 회전



![](https://algorithmtutor.com/images/RBTreeExample.png)
\<Red-Black Tree>

![](https://iq.opengenus.org/content/images/2018/05/avl_insert.jpg)
\<AVL Tree>
## 우선순위 큐 Priority queue

- 우선순위가 높은 데이터가 먼저 나오는 자료구조
- 데이터 삽입, 삭제 연산 지원
	- 삭제 연산 수행 시 최우선순위 데이터를 얻을 수 있음
- 구현 방식에 따른 시간 복잡도
	- 일반적으로 가장 효율적인 힙 사용
- 

| 구현 방법 | 삽입 | 삭제 |
| -------- | ---- | ---- |
| 배열 unsorted array | $O(1)$ | $O(n)$ |
| 연결 리스트 unsorted linked list | $O(1)$ | $O(n)$ |
| 배열 sorted array | $O(n)$ | $O(1)$ |
| 연결 리스트 sorted linked list | $O(n)$ | $O(1)$ |
| 힙 heap | $O(\log n)$ | $O(\log n)$ |

## 힙 heap

- 완전 이진 트리
- 최댓값 또는 최솟값을 빠르게 찾을 수 있는 자료구조
	- 최대 힙 max heap : 부모 노드의 값이 자식 노드의 값보다 크거나 같은 완전 이진 트리
	- 최소 힙 min heap : 부모 노드의 값이 자식 노드의 값보다 작거나 같은 완전 이진 트리
- 연산
	- 데이터 삽입 연산
		- 힙의 맨 끝에서 이루어짐
		- 부모 노드와 우선순위를 비교, 부모 노드보다 우선순위가 높을 시 위치를 바꾸며 루트 노드까지 비교
	- 데이터 삭제 연산
		- 우선순위가 가장 높은 노드를 삭제 = 루트 노드 삭제
		- 루트 노드 자리에는 힙의 마지막 노드를 옮긴 후 힙 재정렬

## 해시 테이블 hash table

- 하나의 키 key 에 대해 하나의 값 value 를 저장하는 형태의 자료 구조
- 키는 해시 함수 hash function 를 사용해 해시를 획득
- 해시 : 값이 저장되어  있는 해시 테이블의 인덱스를 찾을 수 있는 값
	- 해시 함수에 키 입력 시 해시 테이블에서 매칭되는 결과 값에 단번에 접근 가능
	- -> 연산의 평균 시간 복잡도는 $O(1)$

### 해시 충돌

- 서로 다른 키에 대해 같은 해시가 도출되는 것
- 해결 방법
	- 체이닝 chaining
		- 해시 충돌 발생 시 같은 해시가 나오는 키 값을 연결 리스트에 저장
		- 연결 리스트에 노드 저장 -> 저장 공간 제약 적음
		- 하나의 해시 (인덱스) 에 노드가 몰릴 가능성
	- 개방 주소법 open addressing
		- 해시 충돌 발생 시 해당 해시가 아닌 빈 공간에 값 저장
		- 선형 조사법 linear probing
			- h[n] 에서 해시 충돌 발생 시 다음 인덱스로 이동하면서 빈 공간 탐색
			- 충돌 발생 시 다음 인덱스에 데이터 저장 -> 특정 범위에 데이터 몰리는 군집화 현상 발생
		- 이차 조사법 quadratic probing
			- 이차 = 거듭제곱
			- h[n] 에서 해시 충돌 발생 시 거듭제곱한 인덱스만큼 이동 ($1 ^ {2}, 2 ^ {2}, 3 ^ {2} ...$) 하여 빈 공간을 찾으면 저장
			- 선형 조사법 대비 군집화 현상이 적으나 완전 해결은 아님
		- 이중 해싱 double hashing
			- 해시 충돌 발생 시 타 해시 함수를 한 번 더 적용
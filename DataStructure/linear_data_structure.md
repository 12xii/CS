# Linear data structure 선형 자료 구조

- 선형 자료 구조 : 연속적으로 데이터가 나열되는 자료구조

---

## 배열 Array

- 정해진 크기만큼 데이터가 일렬로 저장되는 정적 자료구조
- 각 데이터를 요소 element, 데이터가 가리키는 번호를 인덱스 index라고 함
    - 인덱스는 일반적으로 0번부터 (배열의 크기) - 1까지 참조 가능

### 시간 복잡도

- 접근 시 : $O(1)$
    - 첫 번째 데이터의 주소값에 (데이터 타입 메모리 크기) * (접근하려는 데이터의 인덱스)를 더하면 됨 -> 더하기 연산으로 단번에 접근 가능
- 검색 시 : $O(n)$
    - 앞에서부터 하나씩 읽어나가야 함 -> 최악의 경우 마지막에 존재 -> 배열의 크기만큼 연산
- 삽입 시 : $O(n)$
    - 기존에 있던 데이터를 미루고 삽입 연산을 수행
- 삭제 시 : $O(n)$ or $O(1)$
    - $O(n)$인 경우 : 마지막이 아닌 데이터를 삭제 (삭제 이후 뒤의 데이터들을 모두 앞으로 가져와야 함)
    - $O(1)$인 경우 : 마지막 데이터 삭제

---

## 연결 리스트 Likned list

- 크기가 정해져 있지 않은 동적인 자료구조 dynamic data structure
- 여러 개의 노드 node 로 구성되어 있음

- 종류
    - 단순 연결 리스트
        - 각 노드는 데이터와 다음 노드가 저장된 주소값을 가짐
        - 헤드 포인터 head pointer 와 테일 포인터 tail pointer 로 시작과 끝을 알 수 있음
            - 헤드 포인터를 가리키는 노드는 없음
            - 테일 포인터에는 가리키는 다음 노드가 없음
    - 이중 연결 리스트 double linked linear list
        - 각 노드는 앞의 노드의 주소값과 다음 노드의 주소값을 가짐
        - 양방향 탐색이 가능 -> 순서와 무관하게 연속적인 노드의 탐색에 효율적
        - 메모리를 많이 차지
    - 순환 연결 리스트 (원형 연결 리스트) circular linked linear list
        - 헤드가 마지막 노드를 가리키며, 마지막 노드는 첫 번째 노드를 가리키는 주소값을 저장
        - 새로운 노드를 맨 앞 또는 맨 뒤에 삽입 시 상수 시간 소요
        - 순환 구조이므로 어떤 노드도 다른 모든 노드에 접근 가능

### 시간 복잡도 

- 검색 시 : $O(n)$
    - **선형 탐색** 필요
    - 연결 리스트의 크기가 n일 때 소요되는 시간은 $O(n)$
- 추가 시 : $O(1)$ / $O(n)$
    - 데이터를 추가하는 연산 자체는 $O(1)$이지만 **추가하는 위치까지의 이동이 $O(n)$ 소요**
        - 노드 추가 시 노드 자체를 옮기는 것이 아닌 이전 노드가 가리키는 노드의 주소 값 변경만 필요
    - 즉 맨 앞에 추가하는 경우 $O(1)$, 그 외의 경우 $O(n)$
- 삭제 시 : $O(1)$ / $O(n)$
    - 추가와 마찬가지로 **삭제하는 위치까지의 이동이 $O(n)$ 소요**
    - 첫 번째 데이터 삭제 시 $O(1)$, 그 외의 경우 $O(n)$

---

## 스택 Stack

- 데이터를 쌓는 형태
- LIFO 형태의 자료구조
- 연산
    - 데이터 삽입 : push
    - 데이터 삭제 : pop
- top이라는 변수를 통해 데이터를 마지막으로 저장한 인덱스를 기억
    - -> push / pop 연산에 배열을 사용해도 $O(1)$의 시간 복잡도로 마지막 데이터에 접근
- 구현 시 배열과 연결 리스트 이용

![image](https://blog.kakaocdn.net/dn/bcgR9A/btqSX70PCTe/dMSMQoJcZhDpq4sRRpu3A0/img.png)

> <표> 스택의 연산 및 시간 복잡도

| 연산 | 설명 | 시간 복잡도 |
| --- | --- | --------- |
| push | 스택에 새로운 데이터 삽입 | $O(1)$ |
| pop | 스택에서 가장 위에 있는 데이터 삭제 | $O(1)$ |
| peek | 스택에서 가장 위에 있는 데이터 확인 | $O(1)$ |
| isEmpty | 스택이 비어있는지 확인 | $O(1)$ |
| isFull | 스택이 가득 찼는지 확인 | $O(1)$ |

---

## 큐 Queue

- 데이터가 순차적으로 들어오는 형태
- FIFO
- 큐의 가장 앞은 front, 가장 뒤는 rear라고 함
- 연산
    - 인큐 enqueue : 큐의 가장 뒤에 데이터 추가
    - 디큐 dequeue : 큐의 가장 앞에 데이터 삭제
- 배열과 연결 리스트를 이용해 구현
- 사용 예시
    - 운영체제에서 프로세스가 CPU를 할당받기 전까지 대기하는 **준비 큐**

- 종류
    - 큐
    - 순환 큐 (원형 큐) circular queue
        - 시작과 끝의 구분이 없어 데이터의 삽입과 삭제를 유연하게 할 수 있음
    - 덱 deque / double_ended que
        - 양쪽 끝에서 데이터의 삽입과 삭제가 모두 가능한 구조
        - 큐와 스택을 합한 형태

> <표> 큐의 연산 및 시간 복잡도

| 연산 | 설명 | 시간 복잡도 |
| --- | --- | -------- |
| enqueue | 큐의 rear에 새로운 데이터 삽입 | $O(1)$ |
| dequeue | 큐의 front에서 데이터 삭제 | $O(1)$ |
| peek | 큐의 front에 있는 데이터 확인 | $O(1)$ |
| isEmpty | 큐가 비어 있는지 확인 | $O(1)$ |
| isFull | 큐가 가득 찼는지 확인 | $O(1)$ |

![](https://blog.kakaocdn.net/dn/cGoxX3/btqMLSaP0yX/A93AqK9OhnklNTI8PHLcfk/img.png)